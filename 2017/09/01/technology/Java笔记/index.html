<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;mighto.github.io&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta name="description" content="面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。  运算符的优先级排列，数字越小的表示优先级越高。     “&#x3D;&#x3D;”操作符用于比较两个对象的内存地址值是否相等，equals()方法用于比较两个对象的内容是否一致。  在方法中定义的内部类只能访问方法中的final类型的局部变量，因为用final定义的局部变量相当于是一个常量，它的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记">
<meta property="og:url" content="https://mighto.github.io/2017/09/01/technology/Java%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="均值回归">
<meta property="og:description" content="面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。  运算符的优先级排列，数字越小的表示优先级越高。     “&#x3D;&#x3D;”操作符用于比较两个对象的内存地址值是否相等，equals()方法用于比较两个对象的内容是否一致。  在方法中定义的内部类只能访问方法中的final类型的局部变量，因为用final定义的局部变量相当于是一个常量，它的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mighto.github.io/images/2017/09/priority.png">
<meta property="og:image" content="https://mighto.github.io/images/2017/09/thisandsuper.png">
<meta property="article:published_time" content="2017-09-01T10:00:00.000Z">
<meta property="article:modified_time" content="2020-12-19T15:22:38.219Z">
<meta property="article:author" content="R">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mighto.github.io/images/2017/09/priority.png">


<link rel="canonical" href="https://mighto.github.io/2017/09/01/technology/Java%E7%AC%94%E8%AE%B0/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<script data-pjax src="/js/load-config.js"></script>
  <title>Java笔记 | 均值回归</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">均值回归</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-meself"><a href="/meself" rel="section"><i class="spinner fa-fw"></i>meself</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList%E7%B1%BB%EF%BC%9A"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">ArrayList类：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedList%E7%B1%BB"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">LinkedList类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SortedSet%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.2.</span> <span class="nav-text">SortedSet接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet%E7%B1%BB"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">HashSet类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TreeSet%E7%B1%BB"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">TreeSet类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">Iterator 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ListIterator"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">ListIterator</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">映射接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">Map接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SortedMap%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">SortedMap接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">映射类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractMap%E7%B1%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">AbstractMap类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E7%B1%BB"><span class="nav-number">2.3.2.</span> <span class="nav-text">HashMap类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeMap%E7%B1%BB"><span class="nav-number">2.3.3.</span> <span class="nav-text">TreeMap类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector%E7%B1%BB"><span class="nav-number">2.3.4.</span> <span class="nav-text">Vector类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Stack"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">Stack</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dictionary"><span class="nav-number">2.3.5.</span> <span class="nav-text">Dictionary</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hashtable"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">Hashtable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Properties"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">Properties</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket%E9%80%9A%E8%AE%AF"><span class="nav-number">3.</span> <span class="nav-text">Socket通讯</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">R</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/mighto" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mighto.github.io/2017/09/01/technology/Java%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="R">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="均值回归">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-01 18:00:00" itemprop="dateCreated datePublished" datetime="2017-09-01T18:00:00+08:00">2017-09-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-19 23:22:38" itemprop="dateModified" datetime="2020-12-19T23:22:38+08:00">2020-12-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF-%E6%9C%AC%E6%9C%89%E8%B6%A3/" itemprop="url" rel="index"><span itemprop="name">${技术}本有趣</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <ul>
<li><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。</p>
</li>
<li><p>运算符的优先级排列，数字越小的表示优先级越高。</p>
</li>
</ul>
<p><img src="/images/2017/09/priority.png" alt="运算符优先级"></p>
<ul>
<li><p>“==”操作符用于比较两个对象的内存地址值是否相等，equals()方法用于比较两个对象的内容是否一致。</p>
</li>
<li><p>在方法中定义的内部类只能访问方法中的final类型的局部变量，因为用final定义的局部变量相当于是一个常量，它的生命周期超出方法运行的生命周期。</p>
</li>
<li><p>子类在继承父类时，会继承父类中的全部的属性与方法，super关键字不仅可以调用父类中的构造方法，也可以调用父类中的属性或方法，还可以调用声明为private的属性或方法。</p>
</li>
<li><p>子类重写父类中的方法时，被子类重写的方法不能拥有比父类中更严格的访问权限。</p>
</li>
<li><p>关键字this和super的比较</p>
</li>
</ul>
<p><img src="/images/2017/09/thisandsuper.png" alt="关键字this和super的比较"></p>
<ul>
<li>final:final标记的类不能被继承，final标记的方法不能被子类重写，final标记的变量（成员变量或局部变量）即为常量，只能被赋值一次。</li>
</ul>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><span id="more"></span>

<p>Collection接口是构造类集框架的基础。</p>
<p>核心方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(Object obj)</td>
<td>将obj加入到调用类集中。如果obj被加入到类集中，则返回true；如果obj已经是类集中的一个成员或类集不能被复制时，则返回false。</td>
</tr>
<tr>
<td>boolean addAll(Collection c)</td>
<td>将c中的所有元素都加入到调用类集中，如果操作成功（元素被加入了），则返回true；否则返回false。</td>
</tr>
<tr>
<td>void clear()</td>
<td>从调用类集中删除所有元素。</td>
</tr>
<tr>
<td>boolean contains(Object obj)</td>
<td>如果obj是调用类集的一个元素，则返回true；否则返回false。</td>
</tr>
<tr>
<td>boolean containsAll(Collection c)</td>
<td>如果调用类集包含了c中的所有元素，则返回true；否则返回false。</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>如果调用类集与obj相等，则返回true；否则返回false。</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>返回调用类集的散列码。</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>如果调用类集是空的，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>返回调用类集的迭代程序。</td>
</tr>
<tr>
<td>boolean ramove(Object obj)</td>
<td>从调用类集中删除obj的一个实例。如果这个元素被删除了，则返回true；否则返回false。</td>
</tr>
<tr>
<td>boolean removeAll(Collection c)</td>
<td>从调用类集中删除c的所有元素。如果类集被改变了（也就是元素被删除了），则返回true；否则返回false。</td>
</tr>
<tr>
<td>boolean retainAll(Collection c)</td>
<td>删除调用类集中除了包含c中的元素之外的全部元素。如果类集被改变了（也就是元素被删除了），则返回true；否则返回false。</td>
</tr>
<tr>
<td>int size()</td>
<td>返回调用类集中元素的个数</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含了所有存储在调用类集中的元素。数组元素是类集元素的拷贝。</td>
</tr>
<tr>
<td>Object[] toArray(Object array[])</td>
<td>返回一个数组，该数组仅仅包含了那些类型与数组元素类型匹配的类集元素。数组元素是类集元素的拷贝。如果array的大小比匹配元素的个数大，在数组中，类集元素之后的单元被置为null。如果任一类集元素的类型都不是array的子类型，则引发一个ArrayStoreException异常。</td>
</tr>
</tbody></table>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>List接口扩展了Collection并声明存储一系列元素的类集的特性。使用一个基于零的下标，元素可以通过它们在列表中的位置被插入和访问。一个列表可以包含重复元素。</p>
<p>由List定义的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, Object obj)</td>
<td>将obj插入调用列表，插入位置的下标由index传递。</td>
</tr>
<tr>
<td>Boolean addAll(int index, Collection c)</td>
<td>将c中所有的元素插入到调用列表中，插入点的下标由index传递。如果调用列表改变了，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>返回存储在调用类集内指定下标处的对象。</td>
</tr>
<tr>
<td>int indexOf(Object obj)</td>
<td>返回调用列表中obj的第一个实例的下标。如果obj不是列表中的元素，则返回-1。</td>
</tr>
<tr>
<td>int lastIndexOf(Object obj)</td>
<td>返回调用列表中obj的最后一个实例的下标。如果obj不是列表中的元素，则返回-1。</td>
</tr>
<tr>
<td>ListIterator listIterator()</td>
<td>返回调用列表开始的迭代程序。</td>
</tr>
<tr>
<td>ListIterator listIterator(int index)</td>
<td>返回调用列表在指定下标处开始的迭代程序。</td>
</tr>
<tr>
<td>Object remove(int index)</td>
<td>删除调用列表中index位置的元素并返回删除的元素。删除后，被删除元素后面的元素的下标减一。</td>
</tr>
<tr>
<td>Object set(int index, Object obj)</td>
<td>用obj对调用列表内由index指定的位置进行赋值。</td>
</tr>
<tr>
<td>List subList(int start, int end)</td>
<td>返回一个列表，该列表包括了调用列表中从start到end-1的元素。返回列表中元素也被调用对象引用。</td>
</tr>
</tbody></table>
<h5 id="ArrayList类："><a href="#ArrayList类：" class="headerlink" title="ArrayList类："></a>ArrayList类：</h5><pre><code>* 构造方法

ArrayList():创建一个空的数组列表。

ArrayList(Collection c):创建一个数组列表，该数组列表由类c中的元素初始化。

ArrayList(int capacity):创建一个数组列表，该数组列表有指定的初始容量（capacity）。
</code></pre>
<h5 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h5><pre><code>* 构造方法

LinkedList():创建一个空的链接列表。

LinkedList(Collection c):创建一个链接列表，该链接列表由类c中的元素初始化。

* 其他方法

void addFirst(Object obj):在链表头增加元素，obj是被增加项。

void addLast(Object obj):在链表尾部增加元素，obj是被增加项。

Object getFirst():获得第一个元素。

Object getLast():获得最后一个元素。

Object removeFirst():删除第一个元素。

Object removeLast()：删除最后一个元素。
</code></pre>
<h4 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h4><p>SortedSet接口扩展了Set并说明了按升序排列的集合的特性。</p>
<p>由SortedSet定义的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Comparator comparator()</td>
<td>返回调用被排序集合的比较函数，如果对该集合使用自然顺序，则返回null。</td>
</tr>
<tr>
<td>Object first()</td>
<td>返回调用被排序集合的第一个元素。</td>
</tr>
<tr>
<td>SortedSet headSet(Object end)</td>
<td>返回一个包含那些小于end的元素的SortedSet，那些元素包含在调用被排序集合中。</td>
</tr>
<tr>
<td>Object last()</td>
<td>返回调用排序集合的最后一个元素。</td>
</tr>
<tr>
<td>SortedSet subSet(Object start, Object end)</td>
<td>返回一个SortedSet，它包含了从start到end-1的元素。返回类集中的元素也被调用对象所引用。</td>
</tr>
<tr>
<td>SortedSet tailSet(Object start)</td>
<td>返回一个SortedSet，它包含了那些包含在分类集合中的大于等于start的元素。返回集合中的元素也被调用对象所引用。</td>
</tr>
</tbody></table>
<h5 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h5><p>HashSet扩展AbstractSet并且实现Set接口。它创建一个类集，该类集使用散列表进行存储。而散列表通过使用称之为散列法的机制来存储信息。</p>
<p><em>在散列（hashing）中，一个关键字的信息内容被用来确定唯一的一个值，称为散列码（hash code)。而散列码被用来当做与关键字相连的数据的存储下标。关键字到散列码的转换时自动执行的————看不到散列码本身。程序代码也不能直接索引散列码。</em></p>
<pre><code>* 构造方法：

HashSet():创建一个默认的散列集合。

HashSet(Collection c):创建一个散列集合，用c中的元素初始化散列集合。

HashSet(int capacity):创建一个散列集合，用capacity初始化散列集合的容量。

HashSet(int capacity, float fillRatio):用capacity和fillRatio初始化散列集合的容量和填充比（也称为加载容量）。
</code></pre>
<p><em>填充比必须介于0.0与1.0之间，它决定在散列集合向上调整大小之前，有多少能被充满。具体的说，就是当元素的个数大于散列集合容量乘以它的填充比时，散列集合被扩大。对于没有获得填充比的构造方法，默认使用0.75。</em></p>
<h5 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h5><p>TreeSet为使用树来进行存储的Set接口提供了一个工具，对象按升序存储。访问和检索是很快的。在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet是一个很好的选择。</p>
<pre><code>* 构造方法：

TreeSet():创建一个空的树集合，该树集合将根据其元素的自然顺序按升序排序。

TreeSet(Collection c):创建一个包含了c的元素的树集合。

TreeSet(Comparator comp):创建一个空的树集合，它按照由comp指定的比较方法进行排序。

TreeSet(SortedSet ss):创建一个包含了ss的元素的树集合。
</code></pre>
<h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>如果存在下一个元素，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object next()</td>
<td>返回下一个元素。如果没有下一个元素，则引发NoSuchElementException异常。</td>
</tr>
<tr>
<td>void remove()</td>
<td>删除当前元素，如果试图在调用next()方法之后或调用previous()方法之前，调用remove()方法，则引发IllegalStateException异常。</td>
</tr>
</tbody></table>
<h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>如果存在下一个元素，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object next()</td>
<td>返回下一个元素。如果没有下一个元素，则引发NoSuchElementException异常。</td>
</tr>
<tr>
<td>void remove()</td>
<td>删除当前元素，如果试图在调用next()方法之后或调用previous()方法之前，调用remove()方法，则引发IllegalStateException异常。</td>
</tr>
<tr>
<td>boolean hasPrevious()</td>
<td>如果存在前一个元素，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object previous()</td>
<td>返回前一个元素，如果前一个元素不存在，则引发一个NoSucnElementException异常。</td>
</tr>
<tr>
<td>int nextIndex()</td>
<td>返回下一个元素的下标，如果不存在一下元素，则返回列表的大小。</td>
</tr>
<tr>
<td>int previousIndex()</td>
<td>返回前一个元素的下标，如果前一个元素不存在，则返回-1。</td>
</tr>
<tr>
<td>void set(Object obj)</td>
<td>将obj赋给当前元素。这是上一次调用next()方法或previous()方法最后返回的元素。</td>
</tr>
<tr>
<td>void add(Object obj)</td>
<td>将obj插入列表中的一个元素之前，该元素在下一次调用next()方法时，被返回。</td>
</tr>
</tbody></table>
<h2 id="映射接口"><a href="#映射接口" class="headerlink" title="映射接口"></a>映射接口</h2><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口映射唯一关键字到值。关键字（key）是以后用于检索的对象。给定一个关键字和一个值，可以存储这个值到一个Map对象中。当这个值被存储之后，就可以使用它的关键字来检索它。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void clear()</td>
<td>从调用映射中删除所有的“关键字/值”对</td>
</tr>
<tr>
<td>boolean containsKey(Object k)</td>
<td>如果调用映射中包含了作为关键字的k，则返回true；否则返回false。</td>
</tr>
<tr>
<td>boolean containsValue(Object v)</td>
<td>如果调用映射中包含了作为值的v，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Set entrySet()</td>
<td>返回包含了映射中的项的集合（Set）。该集合包含了类型Map.Entry的对象。这个方法为调用映射提供了一个集合“视图”。</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>如果obj是一个Map并包含了相同的输入，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object get(Object k)</td>
<td>返回与关键字相关联的值。</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>返回调用映射的散列码。</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>如果调用映射是空的，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Set keySet()</td>
<td>返回一个包含调用映射中关键字的集合（Set）。这个方法为调用映射的关键字提供了一个集合“视图”。</td>
</tr>
<tr>
<td>Object put(Object k, Object v)</td>
<td>将一个输入加入调用映射，覆盖原先与该关键字相关联的值。关键字和值分别为k和v。如果关键字已经不存在了，则返回null；否则，返回原先与关键字相关联的值。</td>
</tr>
<tr>
<td>void putAll(Map m)</td>
<td>将所有来自m的输入加入调用映射。</td>
</tr>
<tr>
<td>Object remove(Object k)</td>
<td>删除关键字等于k的输入。</td>
</tr>
<tr>
<td>int size()</td>
<td>返回映射中“关键字/值”对的个数。</td>
</tr>
<tr>
<td>Collection values()</td>
<td>返回一个包含了映射中的值的类集。这个方法为映射中的值提供了一个类集“视图”，映射循环使用两个基本操作：get()和put()。使用put()方法可以将一个指定了关键字和其它对应的值加入映射。为了得到值，可以通过将关键字作为参数来调用get()方法，调用返回该值。</td>
</tr>
</tbody></table>
<h3 id="SortedMap接口"><a href="#SortedMap接口" class="headerlink" title="SortedMap接口"></a>SortedMap接口</h3><p>SortedMap接口扩展了Map，它确保了各项按关键字升序排序。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Comparator comparator()</td>
<td>返回调用排序映射的比较方法。如果调用映射使用的是自然顺序的话，则返回null。</td>
</tr>
<tr>
<td>Object firstKey()</td>
<td>返回调用映射的第一个关键字。</td>
</tr>
<tr>
<td>SortedMap headMap(Object end)</td>
<td>返回一个排序映射，该映射包含了那些关键字小于end的映射输入。</td>
</tr>
<tr>
<td>Object lastKey()</td>
<td>返回调用映射的最后一个关键字。</td>
</tr>
<tr>
<td>SortedMap subMap(Object start, Object end)</td>
<td>返回一个映射，该映射包含了那些关键字大于等于start同时小于end的输入。</td>
</tr>
<tr>
<td>SortedMap tailMap(Object start)</td>
<td>返回一个映射，该映射包含了那些关键字大于等于start的输入。</td>
</tr>
</tbody></table>
<h3 id="映射类"><a href="#映射类" class="headerlink" title="映射类"></a>映射类</h3><h4 id="AbstractMap类"><a href="#AbstractMap类" class="headerlink" title="AbstractMap类"></a>AbstractMap类</h4><p>AbstractMap对于HashMap、TreeMap、WeakHashMap来说是一个超类，它实现了大多数的Map接口。</p>
<h4 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h4><p>HashMap类扩展了AbstractMap类并使用散列表实现Map接口。这允许一些基本操作，如：get()和put()的运行时间保持恒定，即便对大型集合，也是这样的。</p>
<pre><code>* 构造方法

HashMap():创建一个默认的散列映射。

HashMap(Map m):创建一个散列映射，用m的元素初始化散列映射。

HashMap(int capacity):创建一个散列映射，并将散列映射的容量初始化为capacity。

HashMap(int capacity, float fillRatio):用capacity和fillRatio初始化散列映射的容量和填充比。
</code></pre>
<p><em>容量和填充比的概念同HashSet()</em></p>
<h4 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h4><p>TreeMap类通过使用树实现Map接口。TreeMap提供了按排序顺序存储“关键字/值”对的有效手段，同时允许快速检索。应该注意的是，不像散列映射，树映射保证它的元素按照关键字升序排列。</p>
<pre><code>* 构造方法

TreeMap():创建一个空的树映射，该映射使用其关键字的自然顺序来排序。

TreeMap(Comparator comp):创建一个空的树映射，该映射通过使用comp来排序。

TreeMap(Map m):创建一个空的树映射，用从m的输入初始化树映射，该映射使用关键字的自然顺序来排序。

TreeMap(SortedMap sm):创建一个空的树映射，用从sm的输入来初始化一个树映射，该映射将按与sm相同的顺序来排序。
</code></pre>
<p><em>TreeMap实现SortedMap并且扩展了AbstractMap，而它本身并没有另外定义其他方法。</em></p>
<h4 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h4><p>Vector实现动态数组。Vector继承自AbstractList，这与ArrayList相似，但两者不同的是：Vector是同步的，Vector被重新设计来扩展AbstractList和实现List接口，因此现在它与类集是完全兼容的。</p>
<pre><code>* 构造方法

Vector():创建一个原始大小为10的默认矢量。

Vector(int size):创建一个其原始容量由size指定的矢量。

Vector(int size,int incr):创建一个原始容量由size指定，增量由incr指定的矢量。增量指定了矢量每次允许向上改变大小的元素的个数。

Vector(Collection c):创建一个包含了类集c中元素的矢量。

* 其他方法
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>final void addElement(Object element)</td>
<td>将由element指定的对象加入矢量。</td>
</tr>
<tr>
<td>int capacity()</td>
<td>返回矢量的容量。</td>
</tr>
<tr>
<td>Object clone()</td>
<td>返回调用矢量的一个拷贝。</td>
</tr>
<tr>
<td>boolean contains(Object element)</td>
<td>如果element被包含在矢量中，则返回true；否则返回false。</td>
</tr>
<tr>
<td>void copyInto(Object array[])</td>
<td>将包含在调用矢量中的元素复制到由array指定的数组中。</td>
</tr>
<tr>
<td>Object elementAt(int index)</td>
<td>返回由index指定位置的元素。</td>
</tr>
<tr>
<td>Enumeration elements()</td>
<td>返回矢量中元素的一个枚举。</td>
</tr>
<tr>
<td>Object firstElement()</td>
<td>返回矢量的第一个元素。</td>
</tr>
<tr>
<td>int indexOf(Object element)</td>
<td>返回element首次出现的位置下标。如果对象不在矢量中，则返回-1。</td>
</tr>
<tr>
<td>int indexOf(Object element, int start)</td>
<td>返回element在矢量中在start及其之后第一次出现的位置下标。如果该对象不属于矢量的第一部分，则返回-1。</td>
</tr>
<tr>
<td>void insertElementAt(Object element, int index)</td>
<td>在矢量中，在由index指定的位置处加入element。</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>如果矢量是空的，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object lastElement()</td>
<td>返回矢量的最后一个元素。</td>
</tr>
<tr>
<td>int lastIndexOf(Object element)</td>
<td>返回element在矢量中最后一次出现的位置下标。如果对象不包含在矢量中，则返回-1。</td>
</tr>
<tr>
<td>int lastIndexOf(Object element, int start)</td>
<td>返回element在矢量中，在start之前最后一次出现的位置下标。如果该对象不属于矢量的这一部分，则返回-1。</td>
</tr>
<tr>
<td>void removeAllElements()</td>
<td>清空矢量，在这个方法执行以后，矢量的大小为0。</td>
</tr>
<tr>
<td>boolean removeElement(Object element)</td>
<td>从矢量中删除element。如果有多个指定的矢量实例，则其中第一个实例被删除。如果成功删除，则范湖true；否则返回false。</td>
</tr>
<tr>
<td>void removeElementAt(int index)</td>
<td>删除由index指定位置处的元素。</td>
</tr>
<tr>
<td>void setElementAt(Object element, int index)</td>
<td>将由index指定的位置分配给element。</td>
</tr>
<tr>
<td>void setSize(int size)</td>
<td>将矢量中元素的个数设为size。如果新的长度小于旧的长度，元素将丢失；如果新的长度大于旧的长度，则在其后增加null元素。</td>
</tr>
<tr>
<td>int size()</td>
<td>返回矢量中当前元素的个数。</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回矢量的字符串等价形式。</td>
</tr>
<tr>
<td>void trimToSize()</td>
<td>将矢量的容量设为与其当前拥有的长度元素的个数相等。</td>
</tr>
</tbody></table>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack是Vector的一个子类，它实现标准的后进先出堆栈。Stack仅仅定义了创建空堆栈的默认构造方法。Stack包括了由Vector定义的所有方法，同时增加了几种它自己定义的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean empty()</td>
<td>如果堆栈是空的，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Object peek()</td>
<td>返回位于栈顶的元素，但是并不在堆栈中删除它。</td>
</tr>
<tr>
<td>Object pop()</td>
<td>返回位于栈顶的元素，并在进程中删除它。</td>
</tr>
<tr>
<td>Object push(Object element)</td>
<td>将element压入堆栈，同时也返回element。</td>
</tr>
<tr>
<td>int Search(Object element)</td>
<td>在堆栈中搜索element，如果发现了，则返回它相对于栈顶的偏移量；否则返回-1。</td>
</tr>
</tbody></table>
<h4 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h4><p>字典（Dictionary）是一个表示“关键字/值”存储库的抽象类。已被Map取代。</p>
<h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>散列表（Hashtable）继承了Dictionary，并且实现了Map接口。它与HashMap相似，但它是同步的。和HashMap一样，Hastable将“关键字/值”对存储到散列表中。使用Hashtable时，指定一个对象作为关键字，同时指定与该关键字相关联的值。接着该值被散列，而把得到的散列值作为存储在表中的值的下标。</p>
<pre><code>* 构造方法

Hashtable():默认的构造方法，创建一个散列表。

Hashtable(int size):创建一个散列表，该散列表具有由size指定的原始大小。

Hashtable(int size,float fillRatio):创建一个散列表，并且具有由size指定的原始大小和由fillRatio指定的填充比。

Hashtable(Map m):创建一个散列表，该散列表用m中的元素初始化。散列表的容量被设为m中元素的个数的两倍。

* 其他方法
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void clean()</td>
<td>复位并清空散列表。</td>
</tr>
<tr>
<td>Object clone()</td>
<td>返回调用对象的复制。</td>
</tr>
<tr>
<td>boolean contains(Object value)</td>
<td>如果一些值与存在于散列表中的value相等的话，则返回true；否则返回false。</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>如果一些关键字与存在与散列表中的key相等的话，则返回true；否则返回 false。</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>如果一些值与散列表中存在的value相等的话，则返回true；否则返回false。</td>
</tr>
<tr>
<td>Enumeration elements()</td>
<td>返回包含在散列表中的值的枚举。</td>
</tr>
<tr>
<td>Object get(Object key)</td>
<td>返回包含与key相关联的值的对象。如果key不在散列表中，则返回一个空对象。</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断散列表是否为空，为空则返回true；否则返回false。</td>
</tr>
<tr>
<td>Enumeration keys()</td>
<td>返回包含在散列表中的关键字的枚举。</td>
</tr>
<tr>
<td>Object put(Object key, Object value)</td>
<td>将关键字和值插入散列表中。如果key已经不在散列表中，则返回null。如果key存在与散列表中，则返回与key相连的前一个值。</td>
</tr>
<tr>
<td>void rehash()</td>
<td>增大散列表的大小并且对其关键字进行再散列。</td>
</tr>
<tr>
<td>Object remove(Object key)</td>
<td>删除key及其对应的值。返回与key相关联的值。如果key不在散列表中，则返回一个空对象。</td>
</tr>
<tr>
<td>int size()</td>
<td>返回散列表中的项数。</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回散列表的等价字符串形式。</td>
</tr>
</tbody></table>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><p>属性（Properties）是Hashtable的一个子类。它用来保持值的列表，在其中关键字和值都是字符串。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String getProperty(String key)</td>
<td>返回与key相关联的值。如果key既不在列表中，也不在默认属性列表中，则返回一个null对象。</td>
</tr>
<tr>
<td>String getPreperty(String key, String defaultProperty)</td>
<td>返回与key相关联的值。如果key既不在列表中，也不在默认属性列表中，则返回defaultProperty。</td>
</tr>
<tr>
<td>void list(PrintStream streamOut)</td>
<td>将属性列表发送给与streamOut相链接的输出流。</td>
</tr>
<tr>
<td>void list(PrintWriter streamOut)</td>
<td>将属性列表发送给与streamOut相链接的输出就。</td>
</tr>
<tr>
<td>void load(InputStream streanIn)</td>
<td>从与streamIn相链接的输入数据流输入一个属性列表。</td>
</tr>
<tr>
<td>Object setProperty(String key, String value)</td>
<td>将value与key关联。返回与key关联的前一个值。如果不存在这样的关联，则返回null。</td>
</tr>
<tr>
<td>void store(OutputStream streamOut, String description)</td>
<td>在写入由description指定的字符串之后，属性列表被写入与streamOut相链接的输出流。</td>
</tr>
</tbody></table>
<h2 id="Socket通讯"><a href="#Socket通讯" class="headerlink" title="Socket通讯"></a>Socket通讯</h2><p>Socket是网络上运行的两个程序双向通讯的一端，它既可以接收请求，也可以发送请求，利用它可以较为方便地编写网络上数据的传递。</p>
<p>在Java中Socket可以理解为客户端或者服务器端的一个特殊对象，这个对象有两个关键方法，一个是getInputStream()方法，另一个是getOutputStream()方法。getInputStream()方法可以得到一个输入流，客户端的Socket对象上的getInputStream()方法得到的输入流其实就是从服务器端发回的数据流。getOutputStream()方法得到一个输出流，客户端Socket对象上的getOutputStream()方法返回的输出流就是将要发送到服务器端的数据流（其实是一个缓冲区，暂时存储将要发送的数据）。</p>
<p>Socket有两种主要的操作方式：</p>
<ul>
<li>面向连接</li>
</ul>
<p>面向连接的操作使用TCP协议。这个模式下的socket必须在发送数据之前与目的地的socket取得一个连接。一旦连接建立了，sockets就可以使用一个流接口 打开-读-写-关闭。所有的发送的信息都会在另一端以同样的顺序就收。面向连接的操作比无连接的操作效率更低，但是数据的安全性更高。</p>
<pre><code>可以用Socket类、ServerSocket类实现。
</code></pre>
<ul>
<li>无连接</li>
</ul>
<p>无连接操作使用UDP协议。一个数据报是一个独立的单元，它包含了所有的投递信息。可以把它想象成一个信封，它有目的地址和要发送的内容。这个模式下的Socket不需要连接一个目的地的Socket，它只是简单地投出数据报。无连接的操作是快速和高效的，但是数据安全性不佳。</p>
<pre><code>可以用DatagramPacket类、DatagramSocket类实现。
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/07/31/other/interval_year/" rel="prev" title="Interval Year">
                  <i class="fa fa-chevron-left"></i> Interval Year
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/11/09/technology/activiti/" rel="next" title="Activiti笔记">
                  Activiti笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
